/* 
**  mod_mathtex.c -- Apache sample mathtex module
**  [Autogenerated via ``apxs -n mathtex -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_mathtex.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /mathtex in as follows:
**
**    #   apache2.conf
**    LoadModule mathtex_module modules/mod_mathtex.so
**    <Location /mathtex>
**    SetHandler mathtex
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /mathtex and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/mathtex 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_mathtex.c
*/ 

#include "mathtex.h"


#define MATHTEX_DIRECTIVE_INIT_HANDLER(name) \
static const char *mathtex_directive_init_##name( \
                                    cmd_parms *cmd, void *mconfig, char *word)  \
{ \
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config( \
                                cmd->server->module_config, &mathtex_module); \
    conf->name = apr_pstrdup(cmd->pool, word); \
    return NULL; \
}

#define MATHTEX_DIRECTIVE_EXECUTABLE(name) \
        AP_INIT_TAKE1( \
            #name,  \
            mathtex_directive_init_##name,  \
            NULL,  \
            RSRC_CONF | ACCESS_CONF,  \
            "specify path to " #name " executable.")

#define dump_config(name, r) \
        ap_rputs(apr_pstrcat(r->pool, #name ": ", conf->name, "\n", NULL), r)

/* The sample content handler */
static int mathtex_handler(request_rec *r)
{
    if (strcmp(r->handler, "mathtex")) {
        return DECLINED;
    }

    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, r->pool, "mathex_handler");
    if (r->header_only)
        return OK;

    mathtex_object_t *o = mathtex_object_ctor(r);
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, r->pool, "entering process");
    mathtex_process(o);
    mathtex_object_dtor(o);
    return OK;
}
static void mathtex_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(mathtex_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

static const char *mathtex_directive_init_latex(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_latex()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    
    int res = access(word, F_OK);
    if (res != 0) {
        return "specified latex executable path is invalid.";
    }
    conf->latex = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_pdflatex(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_pdflatex()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, cmd->pool, "specified pdflatex executable path is invalid.");
    }
    conf->pdflatex = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_dvipng(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_dvipng()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        return "specified dvipng executable path is invalid.";
    }
    conf->dvipng = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_dvips(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_dvips()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, cmd->pool, "specified dvips executable path is invalid.");
    }
    conf->dvips = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_ps2epsi(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_ps2epsi()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, cmd->pool, "specified ps2epsi executable path is invalid.");
    }
    conf->ps2epsi = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_convert(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_convert()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, cmd->pool, "specified convert executable path is invalid.");
    }
    conf->convert = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_timelimit(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_timelimit()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, cmd->pool, "specified timelimit executable path is invalid.");
    }
    conf->timelimit = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_textarea(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_textarea()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    if (!word) {
        return "textarea is invalid. specify key of query to get TeX expression.";
    }
    conf->textarea = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_home_dir(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_home_dir()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    int res = access(word, F_OK);
    if (res != 0) {
        return "specified HomeDir does not exists. HomeDir should have permission to be written by apache.";
    }
    conf->home_dir = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_latex_method(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_latex_method()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    conf->latex_method = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static const char *mathtex_directive_init_message_level(
                                    cmd_parms *cmd, void *mconfig, char *word)
{
    
    ap_log_perror(APLOG_MARK, APLOG_DEBUG, 0, cmd->pool, "mathtex_directive_init_latex_method()");
    mathtex_config_t *conf = (mathtex_config_t *)ap_get_module_config(
                                cmd->server->module_config, &mathtex_module);
    conf->message_level = atoi(word);
    return NULL;
}

static const command_rec cmds[] = {
//*
    AP_INIT_TAKE1(
            "latex",
            mathtex_directive_init_latex,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to latex executable."),
    AP_INIT_TAKE1(
            "pdflatex",
            mathtex_directive_init_pdflatex,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to pdflatex executable."),
    AP_INIT_TAKE1(
            "dvipng",
            mathtex_directive_init_dvipng,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to dvipng executable."),
    AP_INIT_TAKE1(
            "dvips",
            mathtex_directive_init_dvips,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to dvips executable."),
    AP_INIT_TAKE1(
            "ps2epsi",
            mathtex_directive_init_ps2epsi,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to ps2epsi executable."),
    AP_INIT_TAKE1(
            "convert",
            mathtex_directive_init_convert,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to convert executable."),
    AP_INIT_TAKE1(
            "timelimit",
            mathtex_directive_init_timelimit,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify path to timelimit executable."),
    AP_INIT_TAKE1(
        MATHTEX_DIRECTIVE_TEXTAREA,
        mathtex_directive_init_textarea,
        NULL,
        RSRC_CONF | ACCESS_CONF,
        "specify key of query string for TeX expression."),
    AP_INIT_TAKE1(
        MATHTEX_DIRECTIVE_HOME_DIR,
        mathtex_directive_init_home_dir,
        NULL,
        RSRC_CONF | ACCESS_CONF,
        "specify path to cache directory."),
    AP_INIT_TAKE1(
            MATHTEX_DIRECTIVE_LATEX_METHOD,
            mathtex_directive_init_latex_method,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "specify way PDF or LATEX to output latex image."),
    AP_INIT_TAKE1(
            MATHTEX_DIRECTIVE_MESSAGE_LEVEL,
            mathtex_directive_init_message_level,
            NULL,
            RSRC_CONF | ACCESS_CONF,
            "threshold to determine whether or not write message to log file."),
    {NULL}
};

static void *create_config(apr_pool_t *pool, server_rec *server) {
    mathtex_config_t *conf = (mathtex_config_t *)apr_pcalloc(pool, sizeof(mathtex_config_t));
    conf->latex = NULL;
    conf->pdflatex = NULL;
    conf->dvipng = NULL;
    conf->dvips = NULL;
    conf->ps2epsi = NULL;
    conf->convert = NULL;
    conf->timelimit = NULL;
    conf->textarea = NULL;
    conf->process_log_file_path = NULL;
    conf->home_dir = NULL;
    conf->math_log_file_path = NULL;
    conf->latex_method = "latex";
    conf->message_level = 1;
    return conf;
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA mathtex_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    create_config,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    cmds,                  /* table of config file commands       */
    mathtex_register_hooks  /* register hooks                      */
};

